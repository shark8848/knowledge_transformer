<!DOCTYPE html>
<html>
<head>
<title>knowledge_transformer详细设计文档.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="knowledgetransformer-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3">knowledge_transformer 详细设计文档</h1>
<h2 id="%E6%96%87%E6%A1%A3%E8%A7%84%E8%8C%83%E5%8C%96%E8%BD%AC%E6%8D%A2%E6%9C%8D%E5%8A%A1%E5%BC%95%E6%93%8E">文档规范化转换服务引擎</h2>
<h3 id="1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">1. 设计原则</h3>
<ol>
<li><strong>参数全配置化</strong>：资源限制、鉴权、监控等能力都可通过 YAML / 环境变量动态调节，并支持热重载。</li>
<li><strong>资源与安全限制</strong>：按格式与全局定义文件大小/批量上限，API 层使用 appid/key 鉴权，支持 CLI 管理。</li>
<li><strong>错误码体系</strong>：集中式错误码映射 HTTP 状态与业务状态，支持多语言描述，方便排障与对接（详见文末《附录：错误码总览》）。</li>
<li><strong>插件化架构</strong>：转换逻辑以插件形式装配，可运行时发现新插件并快速扩展支持的格式。</li>
<li><strong>可观测性</strong>：结构化日志、Tracing ID、Prometheus 指标、Flower 监控以及健康检查接口，提升可运维性。</li>
<li><strong>异步高并发处理</strong>：所有任务通过 Celery 执行，提供 Webhook、Result Backend、对象存储下载、预签名 URL 等多种结果获取方式，显著降低 API 阻塞。</li>
</ol>
<h3 id="2-%E5%AE%9E%E7%8E%B0%E6%8F%8F%E8%BF%B0">2. 实现描述</h3>
<p>文档规范化转换服务引擎核心功能为实现覆盖 Office、矢量图、音视频等多种常见格式的转换服务。提供 REST API 与 Celery 异步任务双通道能力。FastAPI 接收文档转换请求并立即返回 <code>task_id</code>，Celery 异步调度任务，Worker 通过插件体系（LibreOffice / Inkscape / FFmpeg 等）执行转换。结果统一存储在对象存储服务器中，消费端可通过 Result Backend 轮询、Webhook 回调或直接访问对象存储获取文件。Celery Pipeline 可以直接调用 Celery 任务，利用 Chain/Group/Chord 等编排方式实现串行、并行及聚合流程。</p>
<h3 id="3-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">3. 处理流程</h3>
<ul>
<li>
<p><strong>内部处理流程</strong></p>
<pre><code class="language-mermaid"><div class="mermaid">sequenceDiagram
    participant API as API 层
    participant Q as Redis 队列/Result Backend
    participant W as Celery Worker
    participant P as 转换插件
    participant S as 对象存储
    participant CB as 回调客户端
    API->>API: 校验输入并生成 task_id
    API->>Q: 封装 conversion.handle_batch
    Q-->>W: 下发任务
    W->>S: 下载源文件或外部 URL
    W->>P: 调用插件执行转换
    P-->>W: 返回转换产物
    W->>S: 上传至 converted/task_id/ 目录
    W->>API: 记录 results[]
    alt callback_url 已配置
        API->>CB: 触发 Webhook 通知
    else 未配置
        API-->>API: 等待客户端自行查询
    end
</div></code></pre>
<ol>
<li>接口校验输入，生成 <code>task_id</code>。</li>
<li>将任务封装为 <code>conversion.handle_batch</code> 并推送到 Redis 队列。</li>
<li>Worker 拉取任务，下载源文件（对象存储 / 外部 URL）。</li>
<li>调用相应插件执行转换，并上传到对象存储 <code>converted/{task_id}/</code> 路径。</li>
<li>记录 <code>results[]</code> 并根据是否设置 <code>callback_url</code> 执行回调。</li>
</ol>
</li>
<li>
<p><strong>外部交互时序</strong></p>
<pre><code class="language-mermaid"><div class="mermaid">sequenceDiagram
  participant C as 客户端
  participant API as API 层
  participant R as Redis 队列/Result Backend
  participant W as Celery Worker
  participant M as 对象存储
  participant Mon as Flower/Prometheus
  C->>API: POST /api/v1/convert
  API-->>C: 202 Accepted + task_id
  API->>R: 推送 conversion.handle_batch
  R->>W: 下发任务
  W->>M: 下载源文件/上传结果
  W-->>R: 更新结果与状态
  alt callback_url 设置
    W->>C: Webhook 通知
  else 轮询/直连
    C->>R: 查询状态
    C->>M: 下载成品
  end
  Mon-->>API: 暴露指标
  Mon-->>W: 任务监控
</div></code></pre>
<ol>
<li>客户端（或 Pipeline Celery 任务）向 <code>/api/v1/convert</code> 提交批量文件，附带回调、优先级等元数据；API 完成校验后立即写入 Redis 队列。</li>
<li>API 以 HTTP 202 返回 <code>task_id</code> 与查询提示，客户端可用该 ID 轮询 Result Backend 或等待回调。</li>
<li>Celery Worker 执行完成后，根据配置触发 Webhook、更新 Result Backend，并将成品上传对象存储；客户端随后可通过 Webhook、Result Backend 或直接访问对象存储下载成品。</li>
<li>Flower 与 Prometheus 持续收集 API/Worker 状态、队列深度与指标，支持运维侧查看单任务轨迹或设置告警阈值。</li>
</ol>
</li>
</ul>
<h3 id="4-%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95">4. 核心算法</h3>
<ul>
<li>
<p><strong>调度算法</strong>：基于 Celery 的多队列与优先级调度。</p>
<ul>
<li><strong>原理</strong>：不同格式或业务线可绑定到独立队列，队列内通过 <code>priority</code> 标签和 <code>prefetch_multiplier</code> 控制 worker 抢占顺序，配合 <code>task_time_limit</code>、<code>soft_time_limit</code> 与 <code>acks_late</code> 机制，确保长耗时任务不会阻塞短任务，且失败可按需重试。</li>
<li><strong>核心逻辑</strong>：API 层根据 <code>files[]</code> 的目标插件、批量大小和 SLA 计算 priority，统一封装为 <code>conversion.handle_batch</code>。Worker 启动时声明可消费的队列列表，并在拉取任务前根据 <code>max_tasks_per_child</code>、并发数设置可承载的批次数。执行过程中，若检测到单批超过 <code>batch_size</code> 或运行超时，任务立即失败并写入结果，剩余文件回退到队列重试，从而避免单个任务占用全部资源。</li>
</ul>
<p><strong>伪代码：</strong></p>
<pre class="hljs"><code><div>function submit_request(files, metadata):
  priority = calc_priority(files, metadata.sla)
  batch = split_files(files, metadata.batch_size)
  for chunk in batch:
    payload = build_payload(chunk, priority, metadata)
    push_to_queue(select_queue(chunk.plugin), payload)

worker_loop():
  settings = load_runtime_limits()
  while worker_alive():
    task = fetch_from_queue(settings.prefetch)
    if not task:
      continue
    with deadline(settings.task_time_limit):
      try:
        for file in task.files:
          artifact = run_plugin(file)
          upload_to_storage(task.task_id, artifact)
        ack(task)
      except TimeoutError:
        mark_failed(task, &quot;timeout&quot;)
        requeue_remaining(task)
      except Exception as exc:
        mark_failed(task, str(exc))
        maybe_retry(task)
</div></code></pre>
</li>
<li>
<p><strong>解析算法</strong>：</p>
<ul>
<li>
<p>文档：利用 LibreOffice headless <code>soffice</code> 完成 Office→PDF/HTML/文本等格式转换。API 层先为每个任务创建独立临时目录，将对象存储或 URL 下载的源文件写入本地，再根据 <code>source_format</code> 选择对应 filter（如 <code>--convert-to pdf:writer_pdf_Export</code>）。执行流程：① 建立隔离 <code>tmpdir</code>；② 调用 <code>soffice</code> 并传入 <code>--headless --norestore --nodefault</code> 等参数，避免互相干扰；③ 监听退出码与 stderr，若失败则根据错误码映射业务状态；④ 成功后校验产物完整性，将文件上传对象存储，并清理 <code>tmpdir</code>。</p>
</li>
<li>
<p>图像/矢量：Inkscape CLI 作为统一渲染器，先将 SVG/EPS/PDF 等矢量格式解析成中间对象，再按业务预设输出 PNG/JPEG/WebP。转换流程包含三步：① 基于 <code>--export-area-drawing</code> 自动裁剪透明留白；② 根据目标分辨率与 <code>dpi</code> 参数动态缩放，确保像素密度一致；③ 如需水印、轮廓描边或背景填充，通过 Inkscape <code>--actions</code> 注入自定义命令。批量图标场景下启用无头模式并发执行，完成后统一上传对象存储。</p>
<ul>
<li><strong>输出流程示例</strong>：
<ol>
<li>解析输入：加载源文件，若为 PDF/EPS 先转换为 Inkscape 支持的内部 SVG。</li>
<li>预处理：执行裁剪、缩放、背景填充与滤镜动作，生成临时工作文件。</li>
<li>渲染导出：根据 <code>target_format</code> 选择 PNG/JPEG/WebP，设置 DPI/压缩质量后输出到 <code>/tmp/rag_converter/&lt;task&gt;</code>。</li>
<li>元数据记录：统计分辨率、文件大小、色彩空间等信息，写入 <code>results[]</code>。</li>
<li>上传与清理：上传对象存储 <code>converted/{task_id}/</code>，完成后删除临时文件。</li>
</ol>
</li>
</ul>
<pre><code class="language-mermaid"><div class="mermaid">flowchart LR
  A[解析输入<br/>SVG/EPS/PDF] --> B[预处理<br/>裁剪/缩放/背景]
  B --> C[渲染导出<br/>PNG/JPEG/WebP]
  C --> D[记录元数据<br/>分辨率/体积]
  D --> E[上传对象存储<br/>converted/task_id/]
  E --> F[清理临时目录]
</div></code></pre>
</li>
<li>
<p>音视频：FFmpeg 提供模板化参数集，按 <code>source_format</code>/<code>target_profile</code> 选择不同 Preset（帧率、比特率、采样率、编码器）。调用链路先拼装基础指令，再叠加业务侧自定义滤镜（如裁剪、降噪、字幕）或压缩策略（CRF、ABR、两遍编码）。任务执行时会根据文件长度动态估算超时时间，并在失败后回退到保守参数或转码降级方案。</p>
<ul>
<li><strong>场景样例</strong>：
<ol>
<li><code>webm→mp4</code>：高码率直播回放转 MP4，使用 x264 Baseline + CRF 23，附带音轨统一到 AAC 128kbps。</li>
<li><code>wav→mp3</code>：语音识别前的批量降采样，固定 16kHz/单声道，并在滤镜中追加噪声抑制。</li>
<li><code>mov→mp4</code>：移动端拍摄素材导出，按分辨率选择 H.265 或 H.264，两遍编码以控制目标文件大小。</li>
<li><code>gif→mp4/png</code>：动图转视频与首帧截图，先以调色板 + scale 滤镜去抖动，再并行输出 MP4 与 PNG。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-%E9%80%9A%E7%94%A8lib%E8%AE%BE%E8%AE%A1">5. 通用lib设计</h3>
<ul>
<li><code>rag_converter.plugins</code>：定义插件抽象基类与注册表，支持热插拔。
<ul>
<li>
<p><code>ConversionInput/ConversionResult</code> 数据类：封装 <code>source_format</code>、<code>target_format</code>、<code>input_path</code>/<code>input_url</code>/<code>object_key</code> 及扩展 <code>metadata</code>，输出侧对应 <code>output_path</code>、<code>object_key</code>、<code>metadata</code>。</p>
</li>
<li>
<p>核心工具函数：</p>
<table>
<thead>
<tr>
<th>工具/方法</th>
<th>输入参数</th>
<th>输出/说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ConversionPlugin.convert(payload)</code></td>
<td><code>payload: ConversionInput</code>（单次转换上下文）</td>
<td>返回 <code>ConversionResult</code>，描述生成文件的路径/对象键及附加元数据；由具体插件实现。</td>
</tr>
<tr>
<td><code>ConversionPlugin.describe()</code></td>
<td>无</td>
<td>字典：<code>slug/source/target</code>，供 <code>/api/v1/formats</code> 暴露能力。</td>
</tr>
<tr>
<td><code>PluginRegistry.register(plugin_cls)</code></td>
<td><code>plugin_cls: Type[ConversionPlugin]</code></td>
<td>将插件注册到 <code>(source,target)</code> 键表；若重复注册抛出 <code>ValueError</code>。</td>
</tr>
<tr>
<td><code>PluginRegistry.get(source, target)</code></td>
<td><code>source:str</code>, <code>target:str</code></td>
<td>按格式返回插件实例，未找到抛出 <code>KeyError</code>。</td>
</tr>
<tr>
<td><code>PluginRegistry.list()</code></td>
<td>无</td>
<td>生成器，依次返回所有插件实例，可用于枚举可用格式。</td>
</tr>
<tr>
<td><code>load_plugins(module_names=None)</code></td>
<td><code>module_names: Iterable[str]</code>（可选，自定义插件模块列表）</td>
<td>依次 <code>import_module</code>，触发模块侧的注册副作用；默认载入内置插件。</td>
</tr>
<tr>
<td><code>read_plugin_module_file(path)</code></td>
<td><code>path: str|Path</code> 指向 YAML 配置文件</td>
<td>返回字符串列表，代表要动态加载的插件模块路径；文件不存在则返回空列表。</td>
</tr>
<tr>
<td><code>write_plugin_module_file(path, modules)</code></td>
<td><code>path: str|Path</code>，<code>modules: Iterable[str]</code></td>
<td>将唯一模块集合写入 YAML（<code>{&quot;modules&quot;: [...]}</code>），用于 CLI/运维同步配置。</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><code>scripts/manage_plugins.sh</code>：统一插件注册、依赖维护与安装脚本。</li>
<li><code>rag_converter.monitoring</code>：暴露 API/Worker 两套 Prometheus 指标。
<table>
<thead>
<tr>
<th>函数</th>
<th>输入参数</th>
<th>输出/说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ensure_metrics_server(port)</code></td>
<td><code>port:int</code> Prometheus 暴露端口</td>
<td>启动一次性指标 HTTP Server，并记录日志。</td>
</tr>
<tr>
<td><code>record_task_accepted(priority)</code></td>
<td><code>priority:str</code></td>
<td>将 <code>conversion_tasks_accepted_total</code> 指标 +1。</td>
</tr>
<tr>
<td><code>record_task_completed(status)</code></td>
<td><code>status:str</code></td>
<td>将 <code>conversion_tasks_completed_total</code> 指标 +1，并区分成功/失败。</td>
</tr>
<tr>
<td><code>collect_dependency_status(settings, celery_app)</code></td>
<td><code>settings:Settings</code>，<code>celery_app:Celery</code></td>
<td>返回字典 <code>{redis,minio,celery}</code>，同时更新 <code>QUEUE_DEPTH</code>、<code>CELERY_WORKERS</code>。</td>
</tr>
<tr>
<td><code>_check_redis(settings)</code></td>
<td><code>settings:Settings</code></td>
<td>内部调用，探测 Redis 并更新 <code>QUEUE_DEPTH</code>（返回 &quot;ok&quot;/错误）。</td>
</tr>
<tr>
<td><code>_check_minio(settings)</code></td>
<td><code>settings:Settings</code></td>
<td>内部调用，探测对象存储连通性（返回 &quot;ok&quot;/错误码）。</td>
</tr>
<tr>
<td><code>_check_celery_workers(celery_app)</code></td>
<td><code>celery_app:Celery</code></td>
<td>内部调用，统计活跃 Worker 数并返回状态。</td>
</tr>
</tbody>
</table>
</li>
<li><code>rag_converter.logging</code>：集中式日志封装，提供结构化 JSON、Trace/TaskID 注入、模块化采样策略，并内置标准格式（访问日志、任务日志、插件调试日志）。与 FastAPI/Celery 中间件集成，支持将关键事件输出到 stdout 或外部日志代理（如 Loki、ELK）。
<table>
<thead>
<tr>
<th>函数</th>
<th>输入参数</th>
<th>输出/说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>configure_logging(settings)</code></td>
<td><code>settings:LoggingSettings</code>（含 level、log_dir、滚动策略）</td>
<td>创建日志目录，配置标准 logging + structlog，启用控制台和文件 Handler。</td>
</tr>
</tbody>
</table>
</li>
<li><code>pipeline_service</code> 示例：包含 Celery 客户端与 Pipeline 自身任务，可在模块内或其他项目复用。
<table>
<thead>
<tr>
<th>函数/方法</th>
<th>输入参数</th>
<th>输出/说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CeleryConverterClient.submit_conversion_chain(files, priority)</code></td>
<td><code>files:List[Dict]</code>，<code>priority:str</code></td>
<td>创建 <code>conversion.handle_batch</code> + <code>pipeline.quality_check</code> + <code>pipeline.post_process</code> 的 Chain，返回 Celery <code>task_id</code>。</td>
</tr>
<tr>
<td><code>submit_conversion_group(file_groups, priority)</code></td>
<td><code>file_groups:List[List[Dict]]</code></td>
<td>并行提交多个转换任务 Group，返回各自 <code>task_id</code>。</td>
</tr>
<tr>
<td><code>submit_conversion_chord(file_batches, priority)</code></td>
<td><code>file_batches:List[List[Dict]]</code></td>
<td>创建并行转换 + 聚合回调的 Chord，返回聚合任务 <code>task_id</code>。</td>
</tr>
<tr>
<td><code>get_result(task_id, timeout)</code></td>
<td><code>task_id:str</code>, <code>timeout:int</code></td>
<td>阻塞等待指定任务完成并返回结果字典。</td>
</tr>
<tr>
<td><code>check_status(task_id)</code></td>
<td><code>task_id:str</code></td>
<td>非阻塞查询任务状态，返回 <code>status/ready/successful</code>。</td>
</tr>
<tr>
<td><code>quality_check_task(conversion_results)</code></td>
<td><code>conversion_results:Dict</code></td>
<td>Celery 任务，遍历转换结果计算 <code>quality_score</code>，输出 <code>stage=quality_checked</code>。</td>
</tr>
<tr>
<td><code>post_process_task(checked_results)</code></td>
<td><code>checked_results:Dict</code></td>
<td>Celery 任务，对通过质量检查的文件提取文本/向量，输出 <code>stage=completed</code>。</td>
</tr>
<tr>
<td><code>aggregate_results_task(batch_results)</code></td>
<td><code>batch_results:List[Dict]</code></td>
<td>Chord 回调，汇总批次成功率并触发通知，返回统计摘要。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="6-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%85%B3%E9%94%AE%E5%B7%A5%E5%85%B7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">6. 接口与关键工具（输入/输出）</h3>
<table>
<thead>
<tr>
<th>接口/工具</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POST /api/v1/convert</code></td>
<td>Headers: <code>X-Appid</code>, <code>X-Key</code>；Body: <code>task_name</code>, <code>priority</code>, <code>callback_url</code>, <code>files[]</code>（<code>source_format</code>, <code>target_format</code>, <code>input_url</code>/<code>object_key</code>, <code>size_mb</code>）</td>
<td><code>status</code>, <code>task_id</code>, <code>message</code></td>
</tr>
<tr>
<td><code>GET /api/v1/formats</code></td>
<td>Headers: <code>X-Appid</code>, <code>X-Key</code></td>
<td><code>formats[]</code>（<code>source</code>, <code>target</code>, <code>plugin</code>）</td>
</tr>
<tr>
<td><code>GET /api/v1/monitor/health</code></td>
<td>Headers: <code>X-Appid</code>, <code>X-Key</code></td>
<td><code>status</code>, <code>timestamp</code>, <code>dependencies{redis,object_storage,celery_workers}</code></td>
</tr>
<tr>
<td><code>GET /healthz</code></td>
<td>无</td>
<td><code>{&quot;status&quot;:&quot;ok&quot;}</code></td>
</tr>
<tr>
<td>Celery 任务 <code>conversion.handle_batch</code></td>
<td><code>payload = {task_id, files[], priority, callback_url, requested_by}</code></td>
<td><code>{&quot;task_id&quot;:..., &quot;results&quot;:[{source,target,status,object_key,output_path,metadata,reason}]}</code></td>
</tr>
<tr>
<td>Pipeline <code>submit_conversion_chain</code></td>
<td><code>files[]</code>, <code>priority</code></td>
<td><code>AsyncResult.id</code>（转换→质量检查→后处理）</td>
</tr>
<tr>
<td>Pipeline <code>submit_conversion_group</code></td>
<td><code>file_groups[][]</code>, <code>priority</code></td>
<td><code>task_ids[]</code>（并行批次）</td>
</tr>
<tr>
<td>Pipeline <code>submit_conversion_chord</code></td>
<td><code>file_batches[][]</code>, <code>priority</code></td>
<td><code>chord_id</code>（并行+聚合）</td>
</tr>
</tbody>
</table>
<h3 id="7-%E5%AE%B9%E9%94%99%E8%AE%BE%E8%AE%A1">7. 容错设计</h3>
<ul>
<li><strong>内部容错</strong>：
<ul>
<li>任务级异常捕获（<code>status=failed</code> + <code>reason</code>）。</li>
<li><code>task_time_limit=300s</code>，避免单任务阻塞。</li>
<li>插件临时目录隔离并执行清理。</li>
<li>对象存储上传失败自动重试一次。</li>
</ul>
</li>
<li><strong>外部容错</strong>：
<ul>
<li>统一错误码 + 客户端重试策略。</li>
<li>Webhook 失败由调用方重发。</li>
<li>Result Backend/对象存储可支撑故障恢复。</li>
<li>Pipeline Celery 自带重试/降级机制（只聚合成功结果、回退为轮询等）。</li>
</ul>
</li>
</ul>
<h3 id="8-%E7%BA%A6%E6%9D%9F">8. 约束</h3>
<ul>
<li>当前仅支持异步模式；需自行实现同步等待（轮询或 Celery Chain）。</li>
<li>默认开启 <code>appid/key</code> 认证。</li>
<li>依赖 Redis、对象存储、LibreOffice、Inkscape、FFmpeg 等基础组件。</li>
<li>文件大小与批量数量受 <code>config/settings.yaml</code> 限制。</li>
</ul>
<h3 id="9-%E5%8F%AF%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B">9. 可处理类型</h3>
<table>
<thead>
<tr>
<th>源格式</th>
<th>目标格式</th>
<th>插件/工具栈</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>doc</code>, <code>docx</code>, <code>ppt</code>, <code>xls</code></td>
<td><code>docx</code>, <code>pdf</code>, <code>html</code></td>
<td>LibreOffice <code>soffice</code> 插件</td>
<td>办公文档标准化、合同归档、文本抽取。</td>
</tr>
<tr>
<td><code>svg</code>, <code>eps</code>, <code>pdf</code></td>
<td><code>png</code>, <code>jpeg</code>, <code>webp</code></td>
<td>Inkscape CLI</td>
<td>产品图/流程图渲染、批量图标输出。</td>
</tr>
<tr>
<td><code>gif</code>, <code>webp</code></td>
<td><code>png</code>, <code>mp4</code></td>
<td>GIF/WebP 插件 + FFmpeg</td>
<td>动图转静帧、营销素材转视频。</td>
</tr>
<tr>
<td><code>wav</code>, <code>flac</code>, <code>ogg</code>, <code>aac</code></td>
<td><code>mp3</code></td>
<td>FFmpeg Audio 插件</td>
<td>语音识别预处理、播客压缩。</td>
</tr>
<tr>
<td><code>avi</code>, <code>mov</code>, <code>mkv</code>, <code>webm</code>, <code>mpeg</code></td>
<td><code>mp4</code></td>
<td>FFmpeg Video 插件</td>
<td>跨平台视频播放、长视频归档。</td>
</tr>
<tr>
<td>自定义格式</td>
<td>自定义输出</td>
<td>第三方/自研插件</td>
<td>按需扩展，例如 CAD→PDF、AI→SVG 等。</td>
</tr>
</tbody>
</table>
<h3 id="10-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">10. 数据存储</h3>
<ul>
<li><strong>缓存与落盘</strong>：
<ul>
<li>Worker 临时目录 <code>/tmp/rag_converter/&lt;task&gt;</code>，任务结束清理。</li>
<li>对象存储 <code>converted/{task_id}/...</code> 长期存储，遵循 bucket 生命周期或人工清理。</li>
<li>Redis Result Backend 配置过期时间，控制历史任务保留周期。</li>
</ul>
</li>
<li><strong>环境约束</strong>：Docker/K8s/裸机均可，需保证 CPU、内存与磁盘资源。</li>
</ul>
<h3 id="11-%E9%85%8D%E7%BD%AE%E8%AE%BE%E8%AE%A1">11. 配置设计</h3>
<ul>
<li>
<p><code>config/settings.yaml</code>：核心配置文件，覆盖 Redis/对象存储、认证、任务限制、监控等。</p>
<table>
<thead>
<tr>
<th>配置段</th>
<th>关键字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>file_limits</code></td>
<td><code>default_max_size_mb</code>, <code>per_format_max_size_mb</code>, <code>max_files_per_task</code></td>
<td>控制单文件/总批次大小与数量上限。</td>
</tr>
<tr>
<td><code>logging</code></td>
<td><code>level</code>, <code>log_dir</code>, <code>max_log_file_size_mb</code>, <code>backup_count</code></td>
<td>日志级别、目录与滚动策略。</td>
</tr>
<tr>
<td><code>monitoring</code></td>
<td><code>prometheus_port</code>, <code>metrics_interval_sec</code>, <code>health_api</code> 等</td>
<td>指标端口、采样周期、健康检查路径。</td>
</tr>
<tr>
<td><code>minio</code></td>
<td><code>endpoint</code>, <code>access_key</code>, <code>bucket</code>, <code>timeout</code></td>
<td>对象存储连接配置。</td>
</tr>
<tr>
<td><code>convert_formats</code></td>
<td><code>source</code>, <code>target</code>, <code>plugin</code></td>
<td>受支持的格式映射及默认插件。</td>
</tr>
<tr>
<td><code>api_auth</code></td>
<td><code>required</code>, <code>app_secrets_path</code>, <code>header_appid</code></td>
<td>API 鉴权开关与凭证路径。</td>
</tr>
<tr>
<td><code>celery</code></td>
<td><code>broker_url</code>, <code>result_backend</code>, <code>task_time_limit_sec</code>, <code>prefetch_multiplier</code></td>
<td>任务调度与执行限制。</td>
</tr>
<tr>
<td><code>rate_limit</code></td>
<td><code>enabled</code>, <code>interval_sec</code>, <code>max_requests</code></td>
<td>API 限流配置。</td>
</tr>
<tr>
<td>其他</td>
<td><code>service_name</code>, <code>plugin_modules_file</code> 等</td>
<td>服务元数据与插件配置文件路径。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>环境变量（前缀 <code>RAG_</code>）：可覆盖 YAML；示例：<code>RAG_REDIS_URL</code>、<code>RAG_MINIO_ENDPOINT</code>、<code>RAG_API_AUTH_REQUIRED</code>。</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>影响字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RAG_REDIS_URL</code></td>
<td><code>celery.broker_url/result_backend</code></td>
<td>覆盖 Celery Broker/Result Backend。</td>
</tr>
<tr>
<td><code>RAG_MINIO_ENDPOINT</code></td>
<td><code>minio.endpoint</code></td>
<td>切换对象存储地址（如 Docker 网络内服务名）。</td>
</tr>
<tr>
<td><code>RAG_API_AUTH_REQUIRED</code></td>
<td><code>api_auth.required</code></td>
<td>控制是否启用 API 鉴权。</td>
</tr>
<tr>
<td><code>RAG_FILE_LIMIT_MAX_SIZE</code></td>
<td><code>file_limits.default_max_size_mb</code></td>
<td>调整默认文件大小限制。</td>
</tr>
<tr>
<td><code>RAG_PROM_PORT</code></td>
<td><code>monitoring.prometheus_port</code></td>
<td>重定义 Prometheus 端口。</td>
</tr>
<tr>
<td>其他 <code>RAG_*</code></td>
<td>任意配置键（驼峰→下划线）</td>
<td>通过 <code>pydantic-settings</code> 自动映射，便于 K8s/Compose 注入。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>CLI/脚本：<code>manage_plugins.sh</code>、<code>make_key.sh</code> 等辅助配置管理。</p>
<table>
<thead>
<tr>
<th>脚本</th>
<th>主要功能</th>
<th>输入/输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>manage_plugins.sh</code></td>
<td>列出/安装/移除插件模块与依赖；同步 <code>config/plugins.yaml</code></td>
<td>命令行参数（如 <code>list/install/remove</code>）；输出操作日志与更新后的配置。</td>
</tr>
<tr>
<td><code>make_key.sh</code></td>
<td>生成 API <code>appid/key</code>，写入 <code>secrets/appkeys.json</code></td>
<td>可选 <code>--appid</code> 指定 ID；输出新密钥并追加到文件。</td>
</tr>
<tr>
<td><code>docker-start.sh</code>/<code>stop.sh</code></td>
<td>一键启动/停止 Docker Compose 组件</td>
<td>读取 <code>.env</code>，调用 <code>docker compose up/down</code>；输出各容器状态。</td>
</tr>
<tr>
<td><code>show_server.sh</code></td>
<td>汇总 API/Worker/对象存储/Redis 状态</td>
<td>无输入；调用健康检查并打印表格。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="12-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%E8%AE%BE%E8%AE%A1">12. 初始化参数设计</h3>
<ul>
<li>
<p><code>start_server.sh</code>：加载配置后启动 FastAPI、Celery Worker 与 Flower。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>启动命令</th>
<th>关键环境变量/参数</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>FastAPI</td>
<td><code>uvicorn rag_converter.app:app --host 0.0.0.0 --port ${API_PORT}</code></td>
<td><code>RAG_CONFIG_FILE</code>, <code>API_PORT</code></td>
<td>启动 REST API（默认 8000），日志写入 <code>logs/api.log</code>。</td>
</tr>
<tr>
<td>Celery Worker</td>
<td><code>celery -A rag_converter.celery_app.celery_app worker -l ${CELERY_LOG_LEVEL}</code></td>
<td><code>CELERY_LOG_LEVEL</code>, <code>RAG_CONFIG_FILE</code></td>
<td>消费转换任务，日志 <code>logs/celery.log</code>。</td>
</tr>
<tr>
<td>Flower</td>
<td><code>celery -A rag_converter.celery_app.celery_app flower --port ${FLOWER_PORT}</code></td>
<td><code>FLOWER_PORT</code>, <code>RAG_CONFIG_FILE</code></td>
<td>提供 Celery UI 监控，日志 <code>logs/flower.log</code>。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Celery Worker 与 Pipeline Celery：通过 <code>.env</code> 中的 <code>CELERY_BROKER_URL</code>、<code>CELERY_RESULT_BACKEND</code>、<code>MINIO_*</code> 等参数初始化；队列名称、优先级、超时均可配置。</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>关键变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换引擎 Worker</td>
<td><code>CELERY_BROKER_URL</code>, <code>CELERY_RESULT_BACKEND</code>, <code>CELERY_DEFAULT_QUEUE</code>, <code>CELERYD_PREFETCH_MULTIPLIER</code>, <code>TASK_TIME_LIMIT</code>, <code>MINIO_*</code></td>
<td>指定 Broker/Backend，限制预取/超时，并提供对象存储凭据。</td>
</tr>
<tr>
<td>Pipeline Celery</td>
<td><code>BROKER_URL</code>, <code>RESULT_BACKEND</code>, <code>MINIO_ENDPOINT</code>, <code>MINIO_ACCESS_KEY</code>, <code>MINIO_SECRET_KEY</code>, <code>PIPELINE_QUEUE</code></td>
<td>连接共享 Redis，访问转换结果与对象存储，配置工作流队列。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="13-%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7">13. 外部工具</h3>
<table>
<thead>
<tr>
<th>组件</th>
<th>最低版本/要求</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>FastAPI</td>
<td>≥ 0.104</td>
<td>提供 REST API 接口层。</td>
</tr>
<tr>
<td>Celery</td>
<td>≥ 5.3</td>
<td>异步任务调度执行。</td>
</tr>
<tr>
<td>Redis</td>
<td>≥ 7</td>
<td>作为 Celery Broker/Result Backend。</td>
</tr>
<tr>
<td>对象存储</td>
<td>S3 兼容（如 MinIO）</td>
<td>存放输入/输出文件。</td>
</tr>
<tr>
<td>LibreOffice</td>
<td>最新 LTS</td>
<td>文档格式转换。</td>
</tr>
<tr>
<td>Inkscape</td>
<td>≥ 1.3</td>
<td>矢量图批量渲染。</td>
</tr>
<tr>
<td>FFmpeg</td>
<td>≥ 5.0</td>
<td>音视频转码/滤镜。</td>
</tr>
<tr>
<td>Flower</td>
<td>≥ 1.2</td>
<td>Celery 监控 UI。</td>
</tr>
<tr>
<td>Prometheus</td>
<td>≥ 2.46</td>
<td>指标采集与告警。</td>
</tr>
</tbody>
</table>
<ul>
<li>Python 依赖见 <code>pyproject.toml</code>；Pipeline 示例的 <code>requirements.txt</code> 已在 README 中说明。</li>
</ul>
<h3 id="14-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1">14. 单元测试设计</h3>
<ul>
<li>
<p><strong>测试工具</strong>：pytest + HTTPX，Celery test worker，对象存储 mock 或本地实例。</p>
</li>
<li>
<p><strong>测试集</strong>：覆盖所有格式、极大/极小文件、非法参数、权限失败、Webhook 失败、部分任务失败以及 Pipeline Chain/Group/Chord 场景。</p>
</li>
<li>
<p><strong>场景文件列表示例</strong>：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>源格式 → 目标格式</th>
<th>大小 (MB)</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>doc_sample_small.doc</code></td>
<td><code>doc → docx</code></td>
<td>0.05</td>
<td>最小文件验证（极小文件处理 + Pipeline Chain）。</td>
</tr>
<tr>
<td><code>ppt_marketing.ppt</code></td>
<td><code>ppt → pdf</code></td>
<td>48</td>
<td>常规文档转换，验证多页结构。</td>
</tr>
<tr>
<td><code>svg_logo.svg</code></td>
<td><code>svg → png</code></td>
<td>0.8</td>
<td>图像/矢量流程 + Pipeline Group。</td>
</tr>
<tr>
<td><code>gif_banner.gif</code></td>
<td><code>gif → mp4</code></td>
<td>25</td>
<td>动图转视频，检查对象存储上传与回调。</td>
</tr>
<tr>
<td><code>webp_large.webp</code></td>
<td><code>webp → png</code></td>
<td>15</td>
<td>静态图较大文件，用于对象存储异常注入。</td>
</tr>
<tr>
<td><code>wav_podcast.wav</code></td>
<td><code>wav → mp3</code></td>
<td>180</td>
<td>大音频文件（接近限制），测试超时与分片策略。</td>
</tr>
<tr>
<td><code>flac_archive.flac</code></td>
<td><code>flac → mp3</code></td>
<td>220</td>
<td>超限文件，触发 <code>FILE_TOO_LARGE</code> 场景。</td>
</tr>
<tr>
<td><code>mov_trailer.mov</code></td>
<td><code>mov → mp4</code></td>
<td>480</td>
<td>视频大型文件（接近 500MB），检验性能与 Pipeline Chord。</td>
</tr>
<tr>
<td><code>mkv_fail.mkv</code></td>
<td><code>mkv → mp4</code></td>
<td>300</td>
<td>插件模拟失败，测试部分任务失败回滚。</td>
</tr>
<tr>
<td><code>invalid_format.bin</code></td>
<td><code>bin → docx</code></td>
<td>1</td>
<td>非法参数/不支持格式，期望 HTTP 400 + 错误码。</td>
</tr>
<tr>
<td><code>auth_test.docx</code></td>
<td><code>docx → pdf</code></td>
<td>2</td>
<td>API key 失效场景，确保返回 401。</td>
</tr>
<tr>
<td><code>webhook_payload.json</code></td>
<td>-</td>
<td>-</td>
<td>Webhook 失败（模拟 500/timeout）场景。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>测试用例（Mock 场景）</strong>：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>分类</th>
<th>场景</th>
<th>Mock 组件</th>
<th>输入示例</th>
<th>期待输出/断言</th>
</tr>
</thead>
<tbody>
<tr>
<td>UT-01</td>
<td>API 层</td>
<td>API 入参合法性</td>
<td>Mock Redis + Celery，HTTPX client</td>
<td><code>files=2</code>, <code>priority=high</code></td>
<td>HTTP 202，<code>task_id</code> 非空，Celery <code>delay</code> 调用 1 次。</td>
</tr>
<tr>
<td>UT-02</td>
<td>API 层</td>
<td>文件大小超限</td>
<td>Mock <code>file_limits</code> 配置</td>
<td><code>size_mb=600</code></td>
<td>HTTP 400，错误码 <code>FILE_TOO_LARGE</code>，Celery 未被调用。</td>
</tr>
<tr>
<td>UT-03</td>
<td>Worker</td>
<td>对象存储下载失败</td>
<td>Mock MinIO SDK 抛 <code>S3Error</code></td>
<td><code>object_key=foo.doc</code></td>
<td><code>results[0].status=failed</code>，<code>reason</code> 含 <code>S3Error</code>，日志 Warning。</td>
</tr>
<tr>
<td>UT-04</td>
<td>Worker</td>
<td>插件执行成功</td>
<td>Mock 插件 <code>convert</code> 返回 <code>/tmp/out.docx</code></td>
<td><code>doc-&gt;docx</code></td>
<td><code>results[0].status=success</code>，上传对象存储 1 次，返回 <code>converted/task/file.docx</code>。</td>
</tr>
<tr>
<td>UT-05</td>
<td>Worker</td>
<td>插件超时</td>
<td>Mock Celery 超时</td>
<td><code>task_time_limit=300s</code></td>
<td>任务 failed，<code>reason=timeout</code>，触发 <code>maybe_retry</code>。</td>
</tr>
<tr>
<td>UT-06</td>
<td>安全</td>
<td>API Key 管理</td>
<td>Mock <code>make_key.sh</code> + <code>secrets/appkeys.json</code></td>
<td>创建 <code>appid=test-client</code>、删除旧 key</td>
<td>创建时生成新 key 写入 JSON；删除后旧 key 调用返回 401，新 key 正常。</td>
</tr>
<tr>
<td>UT-07</td>
<td>回调</td>
<td>Webhook 成功/失败</td>
<td>Mock <code>requests.post</code></td>
<td><code>callback_url=https://example.com</code></td>
<td>成功 200，失败 500 + 重试计数，记录 <code>callback_status</code>。</td>
</tr>
<tr>
<td>UT-08</td>
<td>Pipeline</td>
<td>Chain 工作流</td>
<td>Mock <code>conversion/quality_check/post_process</code></td>
<td>3 步串行</td>
<td>最终 <code>stage=completed</code>，<code>quality_score=0.95</code>，<code>vector_count&gt;0</code>。</td>
</tr>
<tr>
<td>UT-09</td>
<td>Pipeline</td>
<td>Group + Result Backend</td>
<td>Mock <code>AsyncResult</code></td>
<td>三个任务</td>
<td><code>len(task_ids)=3</code>，分别返回 <code>SUCCESS/FAILURE</code> 状态。</td>
</tr>
<tr>
<td>UT-10</td>
<td>监控</td>
<td>依赖检查</td>
<td>Mock Redis/MinIO/Celery Ping</td>
<td>Redis down</td>
<td>返回 <code>{&quot;redis&quot;:&quot;error:RedisError&quot;...}</code>，<code>QUEUE_DEPTH</code>=NaN。</td>
</tr>
<tr>
<td>UT-11</td>
<td>基础设施</td>
<td>Logging 配置</td>
<td>Mock <code>structlog.configure</code></td>
<td><code>level=DEBUG</code>, <code>log_dir=./logs</code></td>
<td>生成 <code>logs/service.log</code>，console+file handler 正常。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>优化/边界/异常覆盖</strong>：</p>
<ul>
<li><strong>性能优化</strong>：在 UT-01/UT-07 基础上增加高并发模拟（pytest-xdist + Celery test worker），观察 <code>queue_depth</code> 与 <code>prefetch_multiplier</code> 对吞吐的影响。</li>
<li><strong>边界值</strong>：针对 <code>file_limits</code>（最小 1KB、最大 500MB）、批次数（1 与上限 10）以及优先级（low/high）设置独立用例，确保阈值附近行为符合预期。</li>
<li><strong>异常路径</strong>：扩展 UT-03/UT-05/UT-06，注入网络抖动、对象存储 5xx、Webhook 超时等异常，验证重试次数、错误码映射与日志完整性。</li>
</ul>
</li>
<li>
<p><strong>测试评测</strong>：</p>
<ul>
<li>断言 HTTP/错误码。</li>
<li>验证 Redis 任务状态与对象存储对象存在。</li>
<li>监控 Prometheus 指标变化，执行性能/压力测试。</li>
</ul>
</li>
<li>
<p><strong>报告样例</strong>：以表格记录测试编号、输入文件/参数、期望结果、实际结果、耗时、系统指标等，便于审计与追踪。</p>
<table>
<thead>
<tr>
<th>测试编号</th>
<th>输入文件/参数</th>
<th>期望结果</th>
<th>实际结果</th>
<th>耗时 (s)</th>
<th>系统指标</th>
</tr>
</thead>
<tbody>
<tr>
<td>TC-0001</td>
<td><code>doc_sample_small.doc</code>, <code>priority=high</code></td>
<td>HTTP 202，<code>task_id</code> 返回，转换成功</td>
<td>同期望</td>
<td>2.4</td>
<td>CPU 35%，内存 +50MB。</td>
</tr>
<tr>
<td>TC-0002</td>
<td><code>flac_archive.flac (220MB)</code></td>
<td>HTTP 400，错误码 <code>FILE_TOO_LARGE</code></td>
<td>同期望</td>
<td>0.8</td>
<td>无 Celery 调用，Redis 连接 1 次。</td>
</tr>
<tr>
<td>TC-0003</td>
<td><code>wav_podcast.wav</code>, Webhook=200</td>
<td><code>results[].status=success</code>，Webhook <code>success</code></td>
<td>Webhook 200，回调记录成功</td>
<td>65</td>
<td>Worker CPU 70%，队列深度保持 &lt;5。</td>
</tr>
<tr>
<td>TC-0004</td>
<td><code>mkv_fail.mkv</code> + 插件超时</td>
<td>任务部分失败，<code>reason=timeout</code>，触发重试</td>
<td>首次失败，重试后成功</td>
<td>310</td>
<td>Celery 任务数 +2，Prometheus <code>conversion_tasks_completed_total{status=&quot;failed&quot;}</code> +1。</td>
</tr>
<tr>
<td>TC-0005</td>
<td>Pipeline Chain（三文件）</td>
<td><code>stage=completed</code>，<code>quality_score&gt;0.9</code></td>
<td><code>stage=completed</code>，<code>quality_score=0.95</code></td>
<td>120</td>
<td>Redis result 节点读写 3 次，Flower 显示 3 步串行完成。</td>
</tr>
<tr>
<td>TC-0006</td>
<td>API Key 创建/删除</td>
<td>新 key 生效，旧 key 返回 401</td>
<td>新 key 鉴权通过，旧 key 401</td>
<td>1.2</td>
<td><code>secrets/appkeys.json</code> 更新一次，API error 日志 +1。</td>
</tr>
</tbody>
</table>
<h3 id="%E9%99%84%E5%BD%95%E9%94%99%E8%AF%AF%E7%A0%81%E6%80%BB%E8%A7%88">附录：错误码总览</h3>
<table>
<thead>
<tr>
<th>错误码</th>
<th>HTTP 状态</th>
<th>业务码</th>
<th>描述</th>
<th>典型触发场景</th>
<th>触发模块/函数</th>
<th>触发条件</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ERR_AUTH_MISSING</code></td>
<td>401</td>
<td>4010</td>
<td>认证信息缺失</td>
<td>请求未携带 <code>X-Appid</code>/<code>X-Key</code>。</td>
<td><code>security.authenticate_request</code></td>
<td>Header/Query 缺少任意 <code>appid</code>/<code>key</code></td>
<td>记录安全告警并拒绝请求。</td>
</tr>
<tr>
<td><code>ERR_AUTH_INVALID</code></td>
<td>401</td>
<td>4011</td>
<td>认证失败，appid 或 key 错误</td>
<td>使用无效 key 或记录已删除的 key。</td>
<td><code>security.authenticate_request</code></td>
<td><code>AppKeyValidator</code> 校验失败</td>
<td><code>AppKeyValidator</code> 热加载 <code>secrets/appkeys.json</code>。</td>
</tr>
<tr>
<td><code>ERR_FILE_TOO_LARGE</code></td>
<td>400</td>
<td>4201</td>
<td>文件大小超限</td>
<td>超过 <code>per_format_max_size_mb</code>（如 <code>flac_archive.flac</code>）。</td>
<td><code>api.routes._validate_request</code></td>
<td>单文件超过 <code>Settings.file_limits.per_format_max_size_mb</code></td>
<td>限制值由配置热更新。</td>
</tr>
<tr>
<td><code>ERR_BATCH_LIMIT_EXCEEDED</code></td>
<td>400</td>
<td>4202</td>
<td>批量数量/体积超限</td>
<td>超出 <code>max_files_per_task</code> 或 <code>max_total_upload_size_mb</code>。</td>
<td><code>api.routes._validate_request</code></td>
<td>文件数量或总大小超限</td>
<td>多批次循环同样生效。</td>
</tr>
<tr>
<td><code>ERR_FORMAT_UNSUPPORTED</code></td>
<td>400</td>
<td>4203</td>
<td>格式暂不支持</td>
<td>未注册插件（如 <code>invalid_format.bin</code>）。</td>
<td><code>api.routes._validate_request</code></td>
<td>源/目标格式对不在插件或配置中</td>
<td>记录 payload 以便排查。</td>
</tr>
<tr>
<td><code>ERR_TASK_FAILED</code></td>
<td>500</td>
<td>5001</td>
<td>任务执行失败</td>
<td>插件崩溃、队列/对象存储异常、内部错误。</td>
<td><code>api.routes.submit_conversion</code></td>
<td><code>handle_conversion_task.delay</code> 抛出异常（队列不可用等）</td>
<td>FastAPI 记录异常栈并触发监控。</td>
</tr>
</tbody>
</table>
</li>
</ul>

</body>
</html>
